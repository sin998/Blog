[TOC]

# 【UE4】加载资源的方式（一）使用引用进行简单加载

# 参考资料&原文链接

[UE4资源加载方式](https://www.sohu.com/a/203578475_667928)

[UE4资源加载方式](https://www.sohu.com/a/203578475_667928)

# 硬性引用、软性引用、构造时引用

ue4提供了许多种机制来控制引用资产的方式并通过扩展将其装入内存。

这些引用分为两种方式：

硬性引用：即对象 A 引用对象 B，并导致对象 B 在对象 A 加载时加载。例如：被“硬”指针指向的资源都会被UE4在启动的时候进行载入，要注意性能问题。有关硬性引用的一个注意事项是，当对象加载并实例化时，以硬性方式引用的资产会自动加载，可能导致内存使用量迅速增加。

软性引用：即对象 A 通过间接机制（例如字符串形式的对象路径）来引用对象 B，软引用的好处是可以按照需要加载。

构造时引用：在构造时加载资产并赋给变量。

# 直接属性引用

这是最常见的资产引用情况，并通过 UPROPERTY 宏公开，面板会公开一个UPROPERTY。

`EditDefaultsOnly`说明此属性可通过属性窗口进行编辑，但只能在原型上进行。此说明符与所有"可见"说明符均不兼容。

```c++
UPROPERTY(EditDefaultsOnly, Category = "Test Texture")
TSoftObjectPtr<UTexture2D> TestImg;
```

![image-20211103150434741](https://sin998-blog-image.oss-cn-beijing.aliyuncs.com/images/202111031504127.png)

# 间接属性引用

间接引用有两种方式：`FStringAssetReferences`和`TAssetPtr`。

美术师或设计师引用资源的最简单的方法是，创建一个UProperty 强指针，并赋予其一个类目。在虚幻引擎4中，如果您使用强指针UObject 属性引用一个资源，那么当加载包含该属性的对象时将会加载那个资源（通过把对象放置在地图中，或者通过从类似于游戏信息这样的东西中进行引用该对象）。

## FStringAssetReferences

`FStringAssetReferences`是一个简单的结构体，包含了一个具有资源完整名称的字符串。如果在类中创建一个那种类型的属性，那么它将会显示在编辑器中。

在Editor中，他的表现就是一个允许异步加载的`UObject*`。它还可以正确的处理烘焙和重定向。

示例：

```c++
public:
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Test")
	FStringAssetReference SAR;
```

![image-20211103115749978](https://sin998-blog-image.oss-cn-beijing.aliyuncs.com/images/202111031157176.png)

可以看出这个的确是支持`UObject`的，什么都能选。

或者你也可以在代码里面这样写，动态加载。

```c++
void UWC_TestUI::Test()
{
	FStringAssetReference MyCharacterBP = "Blueprint'/Game/Core/BP_MyCharacter.BP_MyCharacter'";
	//尝试从路径中查找资源
	UObject* MyCharacterObj = MyCharacterBP.ResolveObject();
	//转成蓝图类型
	UBlueprint* MyCharacterPtr = Cast<UBlueprint>(MyCharacterObj);
	if (MyCharacterPtr != nullptr)
	{
		GetWorld()->SpawnActor<AMyCharacter>(MyCharacterPtr->GeneratedClass);
	}
}
```

FStringAssetReference类的作用主要是通过一个字符串，找到该字符串所对应的资源。或者通过给定的资源，找到该资源所对应的在项目中的路径，也就是前面所说的字符串。

其中，asset.ResolveObject就是查找字符串对应的资源，返回一个UObejct，我们通过将其转化成UBlueprint类型然后再去的他的GenerateClass即可。

UObject常用的函数有：

```c++
	/**
	 * Attempts to find a currently loaded object that matches this path
	 *
	 * @return Found UObject, or nullptr if not currently in memory
	 */
	UObject* ResolveObject() const;
```

尝试查找当前加载的与此路径匹配的对象。

返回找到的UObject，如果当前不在内存中则返回nullptr。

```c++
	/**
	 * Attempts to load the asset, this will call LoadObject which can be very slow
	 * @param InLoadContext Optional load context when called from nested load callstack
	 * @return Loaded UObject, or nullptr if the reference is null or the asset fails to load
	 */
	UObject* TryLoad(FUObjectSerializeContext* InLoadContext = nullptr) const;
```

尝试加载资产，这将调用LoadObject，这可能是非常慢的（LoadObject是同步加载）。

`InLoadContext`：可选加载上下文时，从嵌套的加载callstack调用。

返回一个已经加载的UObject的引用，或者是空或资产加载失败。

```c++
	/** Returns string representation of reference, in form /package/path.assetname[:subpath] */
	FString ToString() const;
```

返回引用的字符串表示形式，格式为`/package/path.assetname[:subpath]`。

## TAssetPtr

`TAssetPtr`基本上就是一个封装了`FStringAssetReferences`的`TWeakObjectPtr`，它使用一个特定的类作为模板，以便限制编辑器用户界面，使策划仅能选择特定的类。

使用`IsPendding()`方法可检查资产是否已准备好可供访问。

如果所引用资源存在于内存中，那么`TAssetPtr.Get()`将返回该资源。如果该资源不在内存中，那么可以调用`ToStringReference()`来查找它引用的资源，并可使用模板化`LoadObject<>()`方法、`StaticLoadObject()`或`FStreamingManager`来加载对象。

前两个方法以同步方式加载资产，这可能会导致帧速率突降。再次调用`TAssetPtr.Get()`可以解除该资源的引用。

示例：

```c++
public:
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Test")
	TAssetPtr<UTexture2D> AP;
```

![image-20211103115810254](https://sin998-blog-image.oss-cn-beijing.aliyuncs.com/images/202111031158750.png)

如果你非要写代码以实现按需加载的话可以继续往下看。

# FStringAssetReference和TAssetPtr的按需加载

前面已经用过它们来作为一个简单引用以加载资源，现在再来看一下它的定义：

可以看到`FStringAssetReference`的本质是`FSoftObjectPath`。

```c++
// Not deprecating these yet as it will lead to too many warnings in games
//UE_DEPRECATED(4.18, "FStringAssetReference was renamed to FSoftObjectPath as it is now not always a string and can also refer to a subobject")
typedef FSoftObjectPath FStringAssetReference;

//UE_DEPRECATED(4.18, "FStringClassReference was renamed to FSoftClassPath")
typedef FSoftClassPath FStringClassReference;
```

`TAssetPtr`的本质是`TSoftObjectPtr`。

```c++
// Not deprecating these yet as it will lead to too many warnings in games
//UE_DEPRECATED(4.18, "TAssetPtr was renamed to TSoftObjectPtr as it is not necessarily an asset")
template<class T=UObject>
using TAssetPtr = TSoftObjectPtr<T>;

//UE_DEPRECATED(4.18, "TAssetSubclassOf was renamed to TSoftClassPtr")
template<class TClass = UObject>
using TAssetSubclassOf = TSoftClassPtr<TClass>;
```

以下内容来自[官方文档 - FSoftObjectPath](https://docs.unrealengine.com/4.27/en-US/API/Runtime/CoreUObject/UObject/FSoftObjectPath/)：

> FSoftObjectPath
>
> A struct that contains a string reference to an object, either a top level asset or a subobject.
>
> 包含对对象(顶级资产或子对象)的字符串引用的结构。
>
> Remarks
>
> A struct that contains a string reference to an object, either a top level asset or a subobject. This can be used to make soft references to assets that are loaded on demand. This is stored internally as an [FName](https://docs.unrealengine.com/4.27/en-US/API/Runtime/Core/UObject/FName/index.html) pointing to the top level asset (/package/path.assetname) and an option a string subobject path. If the MetaClass metadata is applied to a [FProperty](https://docs.unrealengine.com/4.27/en-US/API/Runtime/CoreUObject/UObject/FProperty/index.html) with this the UI will restrict to that type of asset.
>
> 包含对对象(顶级资产或子对象)的字符串引用的结构。这可以用于对按需加载的资产进行软引用。它在内部存储为[FName](https://docs.unrealengine.com/4.27/en-US/API/Runtime/Core/UObject/FName/index.html)，指向顶级资产(/package/path.assetname)和一个选项，一个字符串子对象路径。如果MetaClass元数据被应用到[FProperty](https://docs.unrealengine.com/4.27/en-US/API/Runtime/CoreUObject/UObject/FProperty/index.html)， UI将限制在该类型的资产。

以下内容来自[官方文档 - TSoftObjectPtr](https://docs.unrealengine.com/4.27/en-US/API/Runtime/CoreUObject/UObject/TSoftObjectPtr/)：

> TSoftObjectPtr
>
> [TSoftObjectPtr](https://docs.unrealengine.com/4.27/en-US/API/Runtime/CoreUObject/UObject/TSoftObjectPtr/index.html) is templatized wrapper of the generic [FSoftObjectPtr](https://docs.unrealengine.com/4.27/en-US/API/Runtime/CoreUObject/UObject/FSoftObjectPtr/index.html), it can be used in UProperties
>
> TSoftObjectPtr是通用的模板化包装器，它可以用于UProperties。

以下内容来自[官方文档 - 异步资源加载](https://docs.unrealengine.com/4.27/zh-CN/ProgrammingAndScripting/ProgrammingWithCPP/Assets/AsyncLoading/)

> FSoftObjectPaths和TSoftObjectPtr
>
> 让美术或设计师引用资源的最简单方法是创建硬指针的UProperty并为它指定一个类别。在UE4中，如果有一个硬UObject指针属性引用了一个资源，则加载包含这个属性的对象（放在贴图中，或者从gameinfo等引用）时，就会加载这个资源。如果处理不当，就会在游戏开始时加载全部资源。如果您希望美术/设计师能够使用同一个UI作为硬指针来引用特定资源，而不必总是加载被引用资源，可以使用`FSoftObjectPath`或`TSoftObjectPtr`。
>
> `FSoftObjectPath`是一个简单的结构体，其中有一个字符串包含资源的完整名称。如果您在类中添加这个类型的属性，它就会像`UObject *`属性一样显示在编辑器中。它还会正确处理烘焙和重定向，因此如果您使用SoftObjectPath，就一定能在设备上正确工作。
>
> `TSoftObjectPtr`基本上是包含了`FSoftObjectPath`的`TWeakObjectPtr`，将用于设置特定类的模板，这样就可以限制编辑器UI仅允许选择特定类。如果被引用资源存在于内存中，则`TSoftObjectPtr.Get()`将返回这个资源。如果不存在，可以调用`ToSoftObjectPath()`来找出它引用的资源，使用下述方法加载这个资源，然后再次调用`TSoftObjectPtr.Get()`来取消引用。
>
> 如果美术或设计师要手动设置引用，则`TSoftObjectPtrs`和Soft Object Paths十分有用，但如果想要通过查询等功能来查找符合特定要求的资源，而不加载所有资源，则可以使用资源注册表和对象库。

总结：

FSoftObjectPath（FStringAssetReference ）：包含Asset位置字符串的结构体，可以指向`UObject*`的资源类型。

TSoftObjectPtr（TAssetPtr）：使用FSoftObjectPath构造出来的结构体，用于监视资源状态，指向尚未加载但可以根据请求加载的资产的指针。

TAssetSubclassOf ：指向已定义的基类的子类的指针，该子类尚未加载，但可以根据请求加载。用于指向蓝图而不是基本component（大概是因为蓝图是Asset）。

在C++里面使用：

````c++
//.h
public:
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Test")
	FStringAssetReference SAR;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Test")
	TAssetPtr<UTexture2D> AP;

//.cpp
void UWC_TestUI::OnBtnClickCommonBtn_SARLoad()
{
	FStringAssetReference SAR_SoUnrealPath;
	//检查是否指向一个有效的UObject，返回false则不是一个有效的UObject或者被初始化为null
	if (SAR.IsValid())
	{
		UE_LOG(LogTemp, Warning, TEXT("SAR.AssetName:%s"), *SAR.GetAssetName());
		UE_LOG(LogTemp, Warning, TEXT("SAR.AssetPathName:%s"), *(SAR.GetAssetPathName().ToString()));
		UE_LOG(LogTemp, Warning, TEXT("SAR.AssetPathString:%s"), *SAR.GetAssetPathString());
		SAR_SoUnrealPath = SAR.GetAssetPathString();
	}else
	{
		//指定路径
		SAR_SoUnrealPath = TEXT("Texture2D'/Game/UI/Images/SoUnreal.SoUnreal'");
	}
	//资源同步加载
	UObject * UE4PathObj = UAssetManager::GetStreamableManager().LoadSynchronous(SAR_SoUnrealPath);
	//强转一下
	UTexture2D* UE4PathPtr = Cast<UTexture2D>(UE4PathObj);
	if (UE4PathPtr != nullptr)
	{
		if (Img_SAR != nullptr)
		{
			Img_SAR->SetBrushFromTexture(UE4PathPtr);
		}
	}
}

void UWC_TestUI::OnBtnClickCommonBtn_APLoad()
{
	FStringAssetReference AP_UE4Path;
	//检查是否指向一个有效的UObject，返回false则不是一个有效的UObject或者被初始化为null
	if (AP.IsValid())
	{
		AP_UE4Path = AP.ToSoftObjectPath();
	}else
	{
		//指定路径
		AP_UE4Path = TEXT("Texture2D'/Game/UI/Images/GetUnreal.GetUnreal'");
	}
	//注意这里可以传模板进去，下面就不用再强转了
	UTexture2D * UE4PathPtr = UAssetManager::GetStreamableManager().LoadSynchronous<UTexture2D>(AP_UE4Path);
	//强转一下
	//UTexture2D* UE4PathPtr = Cast<UTexture2D>(UE4PathObj);
	if (UE4PathPtr != nullptr)
	{
		if (Img_AP != nullptr)
		{
			Img_AP->SetBrushFromTexture(UE4PathPtr);
		}
	}
}

````

![image-20211104213618250](https://sin998-blog-image.oss-cn-beijing.aliyuncs.com/images/202111042136649.png)

注意AP是一个TAssetPtr，是一个用UTexture2D包起来的模板，所以在加载的时候已经有了它的类型，就不用强转了。

# 特点

此方法的特点是：

- 简单、对美术或者UI设计师十分友好，可以不动代码而预览效果。
- 在使用之前需要先进行手动指定引用，并且若是没有手动指定引用则可以用代码来指定。代码指定的时候注意资源名或者路径变更的时候会发生错误，因为是写死在代码里面的。这个时候维护就要花额外的时间。

# 本文标签

`游戏开发`、`游戏开发基础`、`Unreal Engine`、`UE资源加载`。
