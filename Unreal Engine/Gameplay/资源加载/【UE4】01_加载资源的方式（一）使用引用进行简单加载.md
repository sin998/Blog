[TOC]

# 【UE4】加载资源的方式（一）使用引用进行简单加载

# 参考资料&原文链接

[UE4资源加载方式](https://www.sohu.com/a/203578475_667928)

# 硬性引用、软性引用、构造时引用

ue4提供了许多种机制来控制引用资产的方式并通过扩展将其装入内存。

这些引用分为两种方式：

硬性引用，即对象 A 引用对象 B，并导致对象 B 在对象 A 加载时加载。例如：被“硬”指针指向的资源都会被UE4在启动的时候进行载入。

软性引用，即对象 A 通过间接机制（例如字符串形式的对象路径）来引用对象 B。

有关硬性引用的一个注意事项是，当对象加载并实例化时，以硬性方式引用的资产会自动加载，可能导致内存使用量迅速增加。

构造时引用：在构造时加载资产并赋给变量。

# 直接属性引用

这是最常见的资产引用情况，并通过 UPROPERTY 宏公开，面板会公开一个UPROPERTY。

`EditDefaultsOnly`说明此属性可通过属性窗口进行编辑，但只能在原型上进行。此说明符与所有"可见"说明符均不兼容。

```c++
UPROPERTY(EditDefaultsOnly, Category = "Test Texture")
TSoftObjectPtr<UTexture2D> TestImg;
```

![image-20211103150434741](https://sin998-blog-image.oss-cn-beijing.aliyuncs.com/images/202111031504127.png)

# 间接属性引用

间接引用有两种方式：`FStringAssetReferences`和`TAssetPtr`。

美术师或设计师引用资源的最简单的方法是，创建一个UProperty 强指针，并赋予其一个类目。在虚幻引擎4中，如果您使用强指针UObject 属性引用一个资源，那么当加载包含该属性的对象时将会加载那个资源（通过把对象放置在地图中，或者通过从类似于游戏信息这样的东西中进行引用该对象）。

## FStringAssetReferences

`FStringAssetReferences`是一个简单的结构体，包含了一个具有资源完整名称的字符串。如果在类中创建一个那种类型的属性，那么它将会显示在编辑器中。

在Editor中，他的表现就是一个允许异步加载的`UObject*`。它还可以正确的处理烘焙和重定向。

示例：

```c++
public:
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Test")
	FStringAssetReference SAR;
```

![image-20211103115749978](https://sin998-blog-image.oss-cn-beijing.aliyuncs.com/images/202111031157176.png)

可以看出这个的确是支持`UObject`的，什么都能选。

或者你也可以在代码里面这样写，动态加载。

```c++
void UWC_TestUI::Test()
{
	FStringAssetReference MyCharacterBP = "Blueprint'/Game/Core/BP_MyCharacter.BP_MyCharacter'";
	//尝试从路径中查找资源
	UObject* MyCharacterObj = MyCharacterBP.ResolveObject();
	//转成蓝图类型
	UBlueprint* MyCharacterPtr = Cast<UBlueprint>(MyCharacterObj);
	if (MyCharacterPtr != nullptr)
	{
		GetWorld()->SpawnActor<AMyCharacter>(MyCharacterPtr->GeneratedClass);
	}
}
```

FStringAssetReference类的作用主要是通过一个字符串，找到该字符串所对应的资源。或者通过给定的资源，找到该资源所对应的在项目中的路径，也就是前面所说的字符串。

其中，asset.ResolveObject就是查找字符串对应的资源，返回一个UObejct，我们通过将其转化成UBlueprint类型然后再去的他的GenerateClass即可。

UObject常用的函数有：

```c++
	/**
	 * Attempts to find a currently loaded object that matches this path
	 *
	 * @return Found UObject, or nullptr if not currently in memory
	 */
	UObject* ResolveObject() const;
```

尝试查找当前加载的与此路径匹配的对象。

返回找到的UObject，如果当前不在内存中则返回nullptr。

```c++
	/**
	 * Attempts to load the asset, this will call LoadObject which can be very slow
	 * @param InLoadContext Optional load context when called from nested load callstack
	 * @return Loaded UObject, or nullptr if the reference is null or the asset fails to load
	 */
	UObject* TryLoad(FUObjectSerializeContext* InLoadContext = nullptr) const;
```

尝试加载资产，这将调用LoadObject，这可能是非常慢的（LoadObject是同步加载）。

`InLoadContext`：可选加载上下文时，从嵌套的加载callstack调用。

返回一个已经加载的UObject的引用，或者是空或资产加载失败。

```c++
	/** Returns string representation of reference, in form /package/path.assetname[:subpath] */
	FString ToString() const;
```

返回引用的字符串表示形式，格式为`/package/path.assetname[:subpath]`。

## TAssetPtr

`TAssetPtr`基本上就是一个封装了`FStringAssetReferences`的`TWeakObjectPtr`，它使用一个特定的类作为模板，以便限制编辑器用户界面，使策划仅能选择特定的类。

使用`IsPendding()`方法可检查资产是否已准备好可供访问。

如果所引用资源存在于内存中，那么`TAssetPtr.Get()`将返回该资源。如果该资源不在内存中，那么可以调用`ToStringReference()`来查找它引用的资源，并可使用模板化`LoadObject<>()`方法、`StaticLoadObject()`或`FStreamingManager`来加载对象。

前两个方法以同步方式加载资产，这可能会导致帧速率突降。再次调用`TAssetPtr.Get()`可以解除该资源的引用。

示例：

```c++
public:
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Test")
	TAssetPtr<UTexture2D> AP;
```

![image-20211103115810254](https://sin998-blog-image.oss-cn-beijing.aliyuncs.com/images/202111031158750.png)

# 本文标签

`游戏开发`、`游戏开发基础`、`Unreal Engine`、`UE4 资源加载`。

